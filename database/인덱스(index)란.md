#  인덱스
인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터 베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.

# 인덱스의 관리
DBMS는 index를 항상 최신의 정렬 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다.
그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오브헤드가 발생한다.
- INSERT: 새로운 데이터에 대한 인덱스를 추가함
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함

# 인덱스의 장점과 단점
- 장점
  - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
  - 전반적인 시스템의 부하를 줄일 수 있다.
  

- 단점
  - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
  - 인덱스를 관리하기 위해 추가 작업이 필요하다.
  - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

만약 `INSERT`, `DELETE`, `UPDATE`가 빈번한 속성에 인덱스를 걸게 되면
**인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과**가 발생할 수 있다.

# 인덱스를 사용하면 좋은 경우
- 규모가 큰 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY가 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

# 인덱스의 자료구조

## 해시 테이블 (Hash Table)
해시 테이블 기반의 DB 인덱스는 `데이터`, `데이터의 위치`를 Key, Value로 사용하여 생성된 해시를 통해 인덱스를 구현한다.
해시 테이블의 시간복잡도는 O(1)이며 매우 빠른 검색을 지원한다.

하지만 DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적인데, 이는 해시가 등호(=) 연산에만 특화되었기 때문이다.
해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 **부등호 연산(<, >)이 빈번히 사용되는
데이터 베이스 검색을 위해서는 해시 테이블이 적합하지 않다.**

## B+Tree
B+Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. B+Tree는 모든 노드에 데이터(Value)를 저장했던 BTree와 다른 특성을 가진다.
- 리프노드(데이터 노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스 노드)들은 데이터를 위한 인덱스(Key)만 가진다.
- 리프노드들은 LinkedList로 연결되어 있다.
- 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다. 
- O(log2n)의 시간복잡도를 갖는다.

# 인덱스의 종류

## 클러스터형 인덱스 (Clustered Index)
 - 테이블당 한개만 생성이 가능
 - 물리적으로 행을 재배열 한다.
 - PK설정 시 그 컬럼은 자동으로 클러스터드 인덱스가 만들어 진다.
 - 인덱스 자체의 리프 페이지가 곧 데이터이다. 즉 테이블 자체가 인덱스이다. (별도의 인덱스 페이지를 만들지 않는다.)
 - 데이터 입력, 수정, 삭제 시 항상 정렬 상태를 유지한다.
 - 비 클러스형 인덱스보다 검색 속도는 더 빠르다. 하지만 데이터의 입력, 수정, 삭제는 느리다.
 - 30% 이내에서 사용해야 좋은 선택도를 가진다.

## 비클러스터형 인덱스 (Non-clustered Index)
 - 테이블당 약 240개의 인덱스를 만들 수 있다.
 - 인덱스 페이지는 로그파일에 저장된다.
 - 레코드의 원본은 정렬되지 않고, 인덱스 페이지만 정렬된다.
 - 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터의 위치하는 포인터(RID)이기 때문에 클러스터형보다 검색 속도는 더 느리지만 데이터의 입력, 수정, 삭제는 더 빠르다.
 - 인덱스를 생성할 때 데이터 페이지는 그냥 둔 상태에서 별도의 인덱스 페이지를 따로 만들기 때문에 용량을 더 차지한다.
 - 3% 이내에서 사용해야 좋은 선택도를 가진다.
 
